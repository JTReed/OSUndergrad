#include <stdio.h>
#include <unistd.h>
#include <math.h>
#include <sys/stat.h>
#include "udp.h"
#include "mfs.h"

/* The size is in bytes */
#define BUFFER_SIZE (4096)
#define BLOCK_SIZE (4096)
#define BITMAP_SIZE (BITMAP_COUNT/8)
#define FS_SIZE (DATA_REGION_OFFSET+DATA_COUNT*BLOCK_SIZE)

#define BITMAP_COUNT (4096)
#define INODE_COUNT (4096)
#define DATA_COUNT (4096)
#define DIR_ENT_COUNT (BLOCK_SIZE/sizeof(MFS_DirEnt_t))

#define INODE_BITMAP_OFFSET (0)
#define DATA_BITMAP_OFFSET (INODE_BITMAP_OFFSET+BITMAP_SIZE)
#define INODE_REGION_OFFSET (DATA_BITMAP_OFFSET+BITMAP_SIZE)
#define DATA_REGION_OFFSET (INODE_REGION_OFFSET+INODE_COUNT*sizeof(inode))

typedef struct inode
{
	int type;
	int size;
	int blocks;
	int pointer[10];
}
inode;

typedef struct datablock
{
	char names[DIR_ENT_COUNT][252];
	int inums[DIR_ENT_COUNT];
}
datablock;

int bitmap_alloc(int fd, int begin_offset)
{
	int offset = -1;
	int bit_offset = -1;
	char *bitmap = malloc(BITMAP_SIZE);

	lseek(fd, begin_offset, SEEK_SET);
	read(fd, bitmap, BITMAP_SIZE);

	/* Find non-full byte */
	while(*(bitmap+(++offset)) == 0xffffffff && offset < BITMAP_SIZE);

	/* Proceed only if a usable byte is found */
	if(offset < BITMAP_SIZE)
	{
		/* Find free bit */
		while((*(bitmap+offset)&(0x1<<(++bit_offset))) != 0);

		/* Set bit */
		*(bitmap+offset) |= (0x1<<(bit_offset));

		lseek(fd, begin_offset, SEEK_SET);
		write(fd, bitmap, BITMAP_SIZE);
	}

	free(bitmap);

	return (offset < BITMAP_SIZE)?(offset*8)+bit_offset:-1;
}

int init_obj(int fd, int inum, int pinum, int type, char *name)
{
	int result = 1;
	int dnum = bitmap_alloc(fd, DATA_BITMAP_OFFSET);
	int dir_ent_index = 1; /* Skip first two entries */

	result = (	result
			&& dnum != -1
			&& inum >= 0
			&& inum < BITMAP_SIZE
			&& pinum >=0
			&& pinum < BITMAP_SIZE );

	/* Update parent directory */
	if(result && inum != pinum)
	{
		int pdir_ent_index = 1; /* Skip first two entries */
		inode parent_inode;
		MFS_DirEnt_t pdir_ent[DIR_ENT_COUNT];

		/* Get the parent inode */
		lseek(fd, INODE_REGION_OFFSET+pinum*sizeof(inode), SEEK_SET);
		read(fd, &parent_inode, sizeof(inode));

		/* Update parent.blocks and rewrite parent inode */
		parent_inode.blocks++;

		lseek(fd, INODE_REGION_OFFSET+pinum*sizeof(inode), SEEK_SET);
		write(fd, &parent_inode, sizeof(inode));

		/* Fill pdir_ent with the blocks the parent points to */
		lseek(	fd,
			DATA_REGION_OFFSET+parent_inode.pointer[0]*BLOCK_SIZE,
			SEEK_SET );

		read(fd, pdir_ent, sizeof(pdir_ent));

		/* Iterate through the blocks until an empty entry is found */
		while(	++pdir_ent_index < DIR_ENT_COUNT
			&& pdir_ent[pdir_ent_index].inum != -1);

		/* Set the new directory's inum and name */
		pdir_ent[pdir_ent_index].inum = inum;

		strncpy(pdir_ent[pdir_ent_index].name, name, 252);

		/* Overwrite the old parent entry with the new one */
		lseek(	fd,
			DATA_REGION_OFFSET+parent_inode.pointer[0]*BLOCK_SIZE,
			SEEK_SET );

		write(fd, pdir_ent, BLOCK_SIZE);
	}

	if(result && type == MFS_DIRECTORY)
	{
		MFS_DirEnt_t dir_ent[DIR_ENT_COUNT];

		/* Set inum and name up for new dir and set all inodes in 
		 * data block to empty
		 */
		dir_ent[0].inum = inum;
		strncpy(dir_ent[0].name, ".", 2);

		dir_ent[1].inum = pinum;
		strncpy(dir_ent[1].name, "..", 3);

		while(++dir_ent_index < DIR_ENT_COUNT)
		{
			dir_ent[dir_ent_index].inum = -1;
		}

		lseek(fd, DATA_REGION_OFFSET+dnum*BLOCK_SIZE, SEEK_SET);
		write(fd, &dir_ent, BLOCK_SIZE);

		printf(	"created file %s with inum %d and pinum %d\n",
			name,
			inum,
			pinum );
	}

	return result?dnum:-1;
}

int init_fs(char *filename)
{
	/* The specs doesn't say anything about the superblock, so we don't
	 * create one.
	 */
	int fd = open(filename, O_RDWR|O_CREAT|O_SYNC, 0666);
	int result = (fd >= 0);
	struct stat fs_stat;

	result = (result && fstat(fd, &fs_stat) == 0);

	if(fs_stat.st_size != FS_SIZE)
	{
		/* ftruncate() fills extra space with zeros */
		result = (result && ftruncate(fd, FS_SIZE) == 0);

		/* bitmap_alloc() should return 0 since there should be no
		 * allocated inode at this point.
		 */
		result = (result && bitmap_alloc(fd, INODE_BITMAP_OFFSET) == 0);

		result = (	result
				&& init_obj(fd, 0, 0, MFS_DIRECTORY, NULL)
				> -1 );
	}

	return result?fd:-1;
}

int handle_lookup(	int fd,
			int pinum,
			char *name,
			int *output_size,
			void **output )
{
	inode parent;
	MFS_DirEnt_t pdir_ent[DIR_ENT_COUNT];
	int block;

	printf("HANDLE LOOKUP\n");

	if(pinum < 0 || pinum > BITMAP_COUNT)
	{
		printf("invalid pinum\n");

		return -1;
	}

	/* Read parent inode from filesystem */
	lseek(fd, INODE_REGION_OFFSET + pinum * sizeof(inode), SEEK_SET);
	read(fd, &parent, sizeof(inode));

	/* Read in parent's data pointers */
	lseek(fd, DATA_REGION_OFFSET+parent.pointer[0]*BLOCK_SIZE, SEEK_SET);
	read(fd, pdir_ent, BLOCK_SIZE);

	printf("parent %d blocks is %d\n", pinum, parent.blocks);

	/* Loop through each block pointer in the parent inode, skipping first
	 * two entries
	 */
	for(block = 2; block < parent.blocks+2; block++)
	{
		if(strncmp(pdir_ent[block].name, name, 252) == 0)
		{
			*output = malloc(sizeof(int));
			*(int *)(*output) = pdir_ent[block].inum;

			*output_size = sizeof(int);

			printf(	"file with name %s and parent %d has inum %d\n",
				name,
				pinum,
				pdir_ent[block].inum );

			return 0;
		}
	}

	printf("file with name %s and parent %d not found\n", name, pinum);

	return -1;
}

int handle_stat(int fd, int inum, int *output_size, void **output)
{
	inode node;
	MFS_Stat_t *stat;

	printf("HANDLE STAT\n");

	stat = malloc(sizeof(MFS_Stat_t));

	if(inum < 0 || inum > BITMAP_COUNT)
	{
		printf("handle stat: invalid pinum");

		return -1;
	}

	/* load up inode */
	lseek(fd, INODE_REGION_OFFSET+inum*sizeof(inode), SEEK_SET);
	read(fd, &node, sizeof(inode));

	stat->type = node.type;
	stat->size = node.size;
	stat->blocks = node.blocks;

	printf("type: %d, size: %d, blocks: %d\n",
		stat->type,
		stat->size,
		stat->blocks);

	*output = stat;
	*output_size = sizeof(MFS_Stat_t);

	return 0;
}

int handle_write(int fd, int inum, char *buffer, int block)
{
	int result = 1;
	inode self;

	printf("HANDLE WRITE\n");

	result = (	result
			&& inum >= 0
			&& inum < BITMAP_COUNT
			&& block >= 0
			&& block < 10 );

	if(result)
	{
		lseek(fd, INODE_REGION_OFFSET+inum*sizeof(inode), SEEK_SET);
		read(fd, &self, sizeof(inode));

		result = (	result
				&& self.type == MFS_REGULAR_FILE
				&& self.blocks >= block );

		printf("in write, %d has type %d and %d >= %d so we'll return %d\n", inum, self.type, self.blocks, block, result-1);
		if(result)
		{
			if(block == self.blocks)
			{
				self.pointer[block]
					= bitmap_alloc(fd, DATA_BITMAP_OFFSET);
			}

			self.blocks++;

			lseek(	fd,
				DATA_REGION_OFFSET+self.pointer[block]*BLOCK_SIZE,
				SEEK_SET );

			write(fd, buffer, BLOCK_SIZE);
			printf("wrote %s to file %d's block %d\n", buffer, inum, block);

			char* boof = malloc(BLOCK_SIZE*sizeof(char));
			lseek(	fd,
				DATA_REGION_OFFSET+self.pointer[block]*BLOCK_SIZE,
				SEEK_SET );
			read(fd, boof, BLOCK_SIZE);
			printf("just confirming, we just wrote '%s'\n", boof);

			lseek(fd, INODE_REGION_OFFSET+inum*sizeof(inode), SEEK_SET);
			write(fd, &self, sizeof(inode));
		}
	}

	return result-1;
}

int handle_read(int fd, int inum, int block, int *output_size, void **output)
{
	inode read_node;
	int result = 1;

	printf("HANDLE READ\n");

	result = (	result
			&& inum >= 0
			&& inum < BITMAP_COUNT
			&& block >= 0
			&& block < 10 );

	if(result)
	{
		/* Read in inode */
		lseek(fd, INODE_REGION_OFFSET+inum*sizeof(inode), SEEK_SET);
		read(fd, &read_node, sizeof(inode));
		printf("indode has type %d\n", read_node.type);
	
		if(read_node.type == MFS_REGULAR_FILE)
		{
			char* buf = malloc(BLOCK_SIZE*sizeof(char));
			printf("reading regular file\n");
			

			lseek(fd, DATA_REGION_OFFSET+read_node.pointer[block]*BLOCK_SIZE, SEEK_SET);
			read(fd, buf, BLOCK_SIZE);

			printf("reading file %d's block %d: ", inum, block);
			printf("'%s'\n", buf);
			*output_size = BLOCK_SIZE;
		}
		else if(read_node.type == MFS_DIRECTORY)
		{
			
			printf("reading directory\n");
			MFS_DirEnt_t blockData[DIR_ENT_COUNT];

			/* Load up relevent block from inode pointers */ 
			lseek(fd, DATA_REGION_OFFSET+read_node.pointer[block]*BLOCK_SIZE, SEEK_SET);
			read(fd, &blockData, BLOCK_SIZE);
	
			/* copy entries into buffer  */
			*output = blockData;
			*output_size = BLOCK_SIZE;
		}
	}
	return result-1;
}

int handle_creat(int fd, int pinum, int type, char *name)
{
	int result = 1;
	int parent_index = -1;
	int inum = bitmap_alloc(fd, INODE_BITMAP_OFFSET);
	MFS_DirEnt_t parent[DIR_ENT_COUNT];
	inode new_inode;

	printf("HANDLE CREAT\n");

	result = (result && inum >= 0);

	/* Check if file exists; return success if it is */
	if(result)
	{
		lseek(fd, DATA_REGION_OFFSET+pinum*BLOCK_SIZE, SEEK_SET);
		read(fd, parent, sizeof(parent));

		while(	++parent_index < DIR_ENT_COUNT
			&& (parent[parent_index].inum == -1
			|| strncmp(parent[parent_index].name, name, 252) != 0));
	}

	/* File doesn't exist */
	if(result && parent_index == DIR_ENT_COUNT)
	{
		printf("being created with type %d\n", type); 
		new_inode.type = type;
		new_inode.size = 0;
		new_inode.blocks = 0;

		lseek(fd, INODE_REGION_OFFSET+inum*sizeof(inode), SEEK_SET);
		write(fd, &new_inode, sizeof(inode));

		result = (result && init_obj(fd, inum, pinum, type, name) > -1);
	}

	return result-1;
}

int handle_unlink(int fd, int pinum, char *name)
{
	printf("HANDLE UNLINK\n");

	return -1;
}

int handle_command(int fd, char *command, char *response)
{
	int i = 0;
	int result = -1;
	int output_size = 0;
	void *output = NULL;
	char *token[3]; /* maximum possible tokens for a valid command is 3 */

	strncpy(response, strtok(command, " "), BUFFER_SIZE);

	do
	{
		token[i] = strtok(NULL, " ");
	}
	while(i < 3 && token[i++] != NULL);

	if(strncmp(command, "LOOKUP", strlen("LOOKUP")) == 0)
	{
		result = handle_lookup(	fd,
					atoi(token[0]),
					token[1],
					&output_size,
					&output );
	}
	else if(strncmp(command, "STAT", strlen("STAT")) == 0)
	{
		result = handle_stat(fd, atoi(token[0]), &output_size, &output);
	}
	else if(strncmp(command, "WRITE", strlen("WRITE")) == 0)
	{
		result = handle_write(	fd,
					atoi(token[0]),
					token[1],
					atoi(token[2]) );
	}
	else if(strncmp(command, "READ", strlen("READ")) == 0)
	{
		result = handle_read(	fd,
					atoi(token[0]),
					atoi(token[1]),
					&output_size,
					&output );
	}
	else if(strncmp(command, "CREAT", strlen("CREAT")) == 0)
	{
		result = handle_creat(	fd,
					atoi(token[0]),
					atoi(token[1]),
					token[2] );
	}
	else if(strncmp(command, "UNLINK", strlen("UNLINK")) == 0)
	{
		result = handle_unlink(fd, atoi(token[0]), token[1]);
	}

	if(result == 0)
	{
		strncat(response, " OK", BUFFER_SIZE-strlen(response));
	}
	else
	{
		strncat(response, " FAIL", BUFFER_SIZE-strlen(response));
	}

	if(output)
	{
		/* The output, if any, will be just beyond the null terminator.
		 * This makes it easy to print out the reponse without having
		 * binary data interferes with the output.
		 */
		memcpy(response+strlen(response)+1, output, output_size);
	}

	return result;
}

int main(int argc, char *argv[])
{
	int portid;
	int fd;
	int sd;

	if(argc != 3)
	{
		printf("Usage: server [portnum] [file-system-image]\n");

		exit(1);
	}

	portid = atoi(argv[1]);
	sd = UDP_Open(portid); /* port # */

	assert(sd > -1);

	fd = init_fs(argv[2]);

	MFS_DirEnt_t block[DIR_ENT_COUNT];
	char* buf;
	int size;
	handle_creat(fd, 0, MFS_REGULAR_FILE, "file1");
	int *inum;
	handle_lookup(fd, 0, "file1", &size, (void*)&inum);
	handle_write(fd, 1, "hello world", 0); 
	handle_read(fd, 1, 0, &size, (void*)&buf);
	int i;
	/*for(i = 0; i < DIR_ENT_COUNT; i++)
	{
		printf("block[%d] inum = %d, name = %s\n", i, block[i].inum, block[i].name);
	} */
	printf("size %d, %s\n", size, buf);

	printf("waiting in loop\n");

	while(1)
	{
		struct sockaddr_in s;
		char buffer[BUFFER_SIZE];

		/* Read message buffer from port sd */
		int rc = UDP_Read(sd, &s, buffer, BUFFER_SIZE);

		if(rc > 0)
		{
			char reply[BUFFER_SIZE];

			/* TODO: handle return values */
			handle_command(fd, buffer, reply);

			printf(	"SERVER:: read %d bytes (message: '%s')\n",
				rc,
				buffer );

			/* Write message buffer to port sd */
			rc = UDP_Write(sd, &s, reply, BUFFER_SIZE);
		}
	}

	return 0;
}

/*
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: t
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 noexpandtab:
 * :indentSize=8:tabSize=8:noTabs=false:
 */
